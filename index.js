// const LinkedList = require('./ds/LinkedList');
// console.log("Link List demo");
// let myLL= new LinkedList().print("create()");
// myLL.append(10).print("append(10)");
// myLL.reverse().print("reverse()");
// myLL.append(5).print("append(5)");
// myLL.append(16).print("append(16)");
// myLL.reverse().print("reverse()");
// myLL.prepend(1).print("prepend(1)");
// myLL.reverse().print("reverse()");
// myLL.insert(2, 99).print("insert(2, 99)");
// myLL.insert(0, 11).print("insert(0, 11)");
// myLL.insert(6, 17).print("insert(6, 17)");
// myLL.remove(0).print("remove(0)");
// myLL.remove(2).print("remove(2)");
// myLL.remove(6);
// myLL.print("remove(6)");
// myLL.remove(4).print("remove(4)");
// myLL.reverse().print("reverse()");

//const DoublyLinkedList = require('./ds/DoublyLinkedList');
// console.log("\n\nDoubly Link List demo");
// let myDLL= new DoublyLinkedList().print("create()");
// myDLL.append(10).print("append(10)");
// myDLL.reverse().print("reverse()");
// myDLL.append(5).print("append(5)");
// myDLL.append(16).print("append(16)");
// myDLL.reverse().print("reverse()");
// myDLL.prepend(1).print("prepend(1)");
// myDLL.reverse().print("reverse()");
// myDLL.insert(2, 99).print("insert(2, 99)");
// myDLL.insert(0, 11).print("insert(0, 11)");
// myDLL.insert(6, 17).print("insert(6, 17)");
// myDLL.remove(0).print("remove(0)");
// myDLL.remove(2).print("remove(2)");
// myDLL.remove(6);
// myDLL.print("remove(6)");
// myDLL.remove(4).print("remove(4)");


// const StackLL = require('./ds/StackLL');
// console.log("\n\nStack Linked List demo");
// let myStackLL = new StackLL();
// myStackLL.print("create()");
// myStackLL.print("peek() = " + myStackLL.peek());
// myStackLL.print("pop() = " + myStackLL.pop());
// myStackLL.push(10).print("push(10)");
// myStackLL.push(15).print("push(15)");
// myStackLL.push(20).print("push(20)");
// myStackLL.print("pop() = " + myStackLL.pop());
// myStackLL.print("peek() = " + myStackLL.peek());
// myStackLL.print("pop() = " + myStackLL.pop());
// myStackLL.print("pop() = " + myStackLL.pop());
// myStackLL.print("isEmpty()= " + myStackLL.isEmpty());

// const Stack = require('./ds/Stack');
// console.log("\n\nStack demo");
// let myStack = new Stack();
// myStack.print("create()");
// myStack.print("peek() = " + myStack.peek());
// myStack.print("pop() = " + myStack.pop());
// myStack.push(10).print("push(10)");
// myStack.push(15).print("push(15)");
// myStack.push(20).print("push(20)");
// myStack.print("pop() = " + myStack.pop());
// myStack.print("peek() = " + myStack.peek());
// myStack.print("pop() = " + myStack.pop());
// myStack.print("pop() = " + myStack.pop());
// myStack.print("isEmpty()= " + myStack.isEmpty());

// const StackArray = require('./ds/StackArray');
// console.log("\n\nStack Array demo");
// let myStackArr = new StackArray();
// myStackArr.print("create()");
// myStackArr.print("peek() = " + myStackArr.peek());
// myStackArr.print("pop() = " + myStackArr.pop());
// myStackArr.push(10).print("push(10)");
// myStackArr.push(15).print("push(15)");
// myStackArr.push(20).print("push(20)");
// myStackArr.print("pop() = " + myStackArr.pop());
// myStackArr.print("peek() = " + myStackArr.peek());
// myStackArr.print("pop() = " + myStackArr.pop());
// myStackArr.print("pop() = " + myStackArr.pop());
// myStackArr.print("isEmpty()= " + myStackArr.isEmpty());

//const QueueLL = require('./ds/QueueLL');
// console.log("\n\nQueue Linked List demo");
// let myQueueLL = new QueueLL();
// myQueueLL.print("create()");
// myQueueLL.print("peek() = " + myQueueLL.peek());
// myQueueLL.print("dequeue()= " + myQueueLL.dequeue());
// myQueueLL.enqueue(10).print("enqueue(10)");
// myQueueLL.enqueue(15).print("enqueue(15)");
// myQueueLL.enqueue(20).print("enqueue(20)");
// myQueueLL.print("dequeue()= " + myQueueLL.dequeue());
// myQueueLL.print("peek() = " + myQueueLL.peek());
// myQueueLL.print("dequeue()= " + myQueueLL.dequeue());
// myQueueLL.print("dequeue()= " + myQueueLL.dequeue());
// myQueueLL.print("dequeue()= " + myQueueLL.dequeue());

// const Queue = require('./ds/Queue');
// console.log("\n\nQueue demo");
// let myQueue = new Queue();
// myQueue.print("create()");
// myQueue.print("peek() = " + myQueue.peek());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.enqueue(10).print("enqueue(10)");
// myQueue.enqueue(15).print("enqueue(15)");
// myQueue.enqueue(20).print("enqueue(20)");
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("peek() = " + myQueue.peek());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("dequeue()= " + myQueue.dequeue());

// const QueueStack = require('./ds/QueueStack');
// console.log("\n\nQueue Stack demo");
// let myQueue = new QueueStack();
// myQueue.print("create()");
// myQueue.print("peek() = " + myQueue.peek());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.enqueue(10).print("enqueue(10)");
// myQueue.enqueue(15).print("enqueue(15)");
// myQueue.enqueue(20).print("enqueue(20)");
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("peek() = " + myQueue.peek());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("dequeue()= " + myQueue.dequeue());
// myQueue.print("dequeue()= " + myQueue.dequeue());

// const CustomArray = require('./ds/Array');
// console.log('\n\nArray demo');
// let myArray = new CustomArray();
// console.log(myArray.get(0));
// console.log(myArray.push(1));
// console.log(myArray);

// const HashTable = require('./ds/HashTable');
// console.log('\n\nHash Table demo');
// let myHashTable = new HashTable(2);
// myHashTable.set('grapes', 10000);
// myHashTable.print();
// myHashTable.set('apples', 54);
// myHashTable.print();
// myHashTable.set('potatoes', 78);
// myHashTable.print();
// console.log(myHashTable.get('grapes'));
// console.log(myHashTable.keys());

// const HashTableLL = require('./ds/HashTableLL');
// console.log('\n\nHash Table Linked List demo');
// let myHashTableLL = new HashTableLL(50);
// myHashTableLL.set('grapes', 10000);
// myHashTableLL.print();
// myHashTableLL.set('apples', 54);
// myHashTableLL.print();
// myHashTableLL.set('potatoes', 78);
// myHashTableLL.print();
// console.log(myHashTableLL.get('grapes'));
// console.log(myHashTableLL.keys());


// const HashTable = require('./ds/HashTable');
// function firstRecurringCharacter(input) {
//   const counts = new HashTable(10);
//   for (let i = 0; i < input.length; i++) {
//     let number = input[i];
//     if (counts.get(number)) {
//       return number;
//     }
//     counts.set(number, 1);
//   }
//   return null;
// }

// console.log(firstRecurringCharacter([2,5, 1,2, 3, 5, 1, 2, 3]));

// const BinaryHeap = require('./ds/BinaryHeap');
// let myMaxHeap = new BinaryHeap(true);
// myMaxHeap.add(3).print("+3");
// myMaxHeap.add(2).print("+2");
// myMaxHeap.add(5).print("+5");
// myMaxHeap.add(1).print("+1");
// myMaxHeap.add(6).print("+6");
// myMaxHeap.add(10).print("+10");
// myMaxHeap.add(15).print("+15");
// console.log("peek", myMaxHeap.peek());
// console.log("ext", myMaxHeap.extract())
// myMaxHeap.print("final");

// const BinaryHeap = require('./ds/BinaryHeap');
// let myMinHeap = new BinaryHeap(false);
// myMinHeap.add(3).print("+3");
// myMinHeap.add(2).print("+2");
// myMinHeap.add(5).print("+5");
// myMinHeap.add(1).print("+1");
// myMinHeap.add(6).print("+6");
// myMinHeap.add(10).print("+10");
// myMinHeap.add(15).print("+15");
// console.log("peek", myMinHeap.peek());
// console.log("ext", myMinHeap.extract())
// myMinHeap.print("final");


// const BinaryHeap = require('./ds/BinaryHeap');
// const minHeap = new BinaryHeap(false);
// const maxHeap = new BinaryHeap(true);
// function runningMedian(a) {
//   const result = [];
  
//   for (let i = 0; i< a.length; i++) {
//     if(i===0) {
//       minHeap.add(a[i]);
//     } else {
//       if (a[i] <= median()) {
//         maxHeap.add(a[i]);
//       } else {
//         minHeap.add(a[i]);
//       }
//     }
//     fixChaos();
//     let m = median();
//     result.push(format(m));
//     console.log(a[i]);
//     maxHeap.print("Max");
//     minHeap.print("Min");
//   }
//   return result;
// }

// function fixChaos(){
//   //if sizes of heaps differ by 2, then it's a chaos, since median must be the middle element
//   if( Math.abs(maxHeap.size() - minHeap.size()) > 1) {
//       //check which one is the culprit and take action by kicking out the root from culprit into victim
//       if(maxHeap.size() > minHeap.size()){
//           minHeap.add(maxHeap.extract());
//       }
//       else{ maxHeap.add(minHeap.extract());}
//   }
// }

// function median() {
//   if( maxHeap.size() === minHeap.size()) {
//     return (maxHeap.peek() + minHeap.peek())/2 ;
//   }
//   else if (maxHeap.size() > minHeap.size())
//   { 
//     return maxHeap.peek();
//   }
//   else { 
//     return minHeap.peek();
//   }
// }

// function format(num) {
//   return (Math.round(parseFloat(num) * 10)/10).toFixed(1);
// }



// let result = runningMedian([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
// console.log(result);


// function isBalanced(s) {
//   const stack = [];
//   const opening = ['(', '[', '{'];
//   if (s.length === 0) {
//     return 'NO';
//   }
//   for (let i=0; i<s.length; i++) {
//     if (opening.includes(s[i])) {
//       stack.push(s[i]);
//     }
//     else {
//       let bracket = stack.pop();
//       if (bracket === undefined
//         || (bracket === '(' && s[i] !== ')')
//         || (bracket === '[' && s[i] !== ']')
//         || (bracket === '{' && s[i] !== '}')
//       ) {
//         return 'NO';
//       }
//     }
//   }
//   return (stack.length > 0) ? 'NO' : 'YES';
// }

// console.log(isBalanced('{[()]}'));

// const BST = require('./ds/BinarySearchTree');
// const tree = new BST();
// tree.insert(9);
// tree.insert(4);
// tree.insert(6);
// tree.insert(20);
// tree.insert(170);
// tree.insert(15);
// tree.insert(1);

// console.log(JSON.stringify(traverse(tree.root)));

// function traverse(node) {
//   const tree = {vale: node.value};
//   tree.left = node.left === null ? null : traverse(node.left);
//   tree.right = node.right === null ? null : traverse(node.right);
//   return tree;
// }

// console.log(tree.lookup(50));

// const Graph = require('./ds/Graph');
// const myGraph = new Graph();
// myGraph.addVertex('0');
// myGraph.addVertex('1');
// myGraph.addVertex('2');
// myGraph.addVertex('3');
// myGraph.addVertex('4');
// myGraph.addVertex('5');
// myGraph.addVertex('6');
// myGraph.addEdge('0', '1');
// myGraph.addEdge('0', '2');
// myGraph.addEdge('1', '2');
// myGraph.addEdge('1', '3');
// myGraph.addEdge('2', '4');
// myGraph.addEdge('3', '4');
// myGraph.addEdge('4', '5');
// myGraph.addEdge('5', '6');
// console.log(myGraph.adjacentList);
// myGraph.showConnections();


// Find clusters excercise.
// function countIslandsDFS(grid, rows, cols) {
//   let count = 0;
//   const visited = [];
//   for (let i = 0; i < rows; i++) {
//     for (let j = 0; j < cols; j++) {
//       if (visited[i] === undefined) {
//         visited[i] = [];
//       }
//       if (grid[i][j] === 1 && visited[i][j] === undefined) {
//         dfs(grid, i, j, visited);
//         count++;
//       }
//     }
//   }
//   return count;
// }

// function dfs(grid, row, col, visited) {
//   const rows = [-1, -1, -1, 0, 0, 1, 1, 1];
//   const cols = [-1, 0, 1, -1, 1, -1 , 0, 1];
//   if (visited[row] === undefined) {
//     visited[row] = [];
//   }
//   visited[row][col] = 1;
//   for (k = 0; k < 8; k++) {
//     if (possibleCell(grid, row + rows[k], col + cols[k], visited)) {
//       dfs(grid, row + rows[k], col + cols[k], visited);
//     }
//   }
// }

// function countIslandsDFSStack(grid, rows, cols) {
//   let count = 0;
//   const visited = [];
//   for (let i = 0; i < rows; i++) {
//     for (let j = 0; j < cols; j++) {
//       if (visited[i] === undefined) {
//         visited[i] = [];
//       }
//       if (grid[i][j] === 1 && visited[i][j] === undefined) {
//         dfsStack(grid, i, j, visited);
//         count++;
//       }
//     }
//   }
//   return count;
// }

// function dfsStack(grid, row, col, visited) {
//   const rows = [-1, -1, -1, 0, 0, 1, 1, 1];
//   const cols = [-1, 0, 1, -1, 1, -1 , 0, 1];
//   const stack = [[row, col]];
//   visited[row][col] = 1;
//   while (stack.length) {
//     const cell = stack.pop();
//     for (k = 0; k < 8; k++) {
//       const i = cell[0] + rows[k];
//       const j = cell[1] + cols[k];
//       if (possibleCell(grid, i, j, visited)) {
//         visited[i][j] = 1;
//         stack.push([i, j]);
//       }
//     }
//   }
// }

// function countIslandsBFS(grid, rows, cols) {
//   let count = 0;
//   const visited = [];
//   for (let i = 0; i < rows; i++) {
//     for (let j = 0; j < cols; j++) {
//       if (visited[i] === undefined) {
//         visited[i] = [];
//       }
//       if (grid[i][j] === 1 && visited[i][j] === undefined) {
//         bfs(grid, i, j, visited);
//         count++;
//       }
//     }
//   }
//   return count;
// }

// function bfs(grid, row, col, visited) {
//   const rows = [-1, -1, -1, 0, 0, 1, 1, 1];
//   const cols = [-1, 0, 1, -1, 1, -1 , 0, 1];
//   const queue = [[row, col]];
//   visited[row][col] = 1;
//   while (queue.length) {
//     const cell = queue.shift();
//     for (k = 0; k < 8; k++) {
//       const i = cell[0] + rows[k];
//       const j = cell[1] + cols[k];
//       if (possibleCell(grid, i, j, visited)) {
//         visited[i][j] = 1;
//         queue.push([i, j]);
//       }
//     }
//   }
// }

// function possibleCell(grid, row, col, visited) {
//   if (visited[row] === undefined) {
//     visited[row] = [];
//   }
//   return (row >= 0 && row < grid.length 
//     && col >= 0 && col < grid[0].length
//     && grid[row][col] === 1
//     && visited[row][col] === undefined);
// }

// const matrix = [
//   [1, 1, 0, 0],
//   [0, 1, 0, 0],
//   [0, 0, 0, 0],
//   [1, 0, 1, 1],
//   [1, 1, 1, 1]
// ];

// console.log(countIslandsDFS(matrix, 5, 4));
// console.log(countIslandsDFSStack(matrix, 5, 4));
// console.log(countIslandsBFS(matrix, 5, 4));

// Logs sort excercise.
// function getSortedLogs(logs) {
//   logs.sort(function (a, b) {
//     const rec1 = a.split(" ", 2);
//     const rec2 = b.split(" ", 2);
//     const isDigit1 = Boolean(parseInt(rec1[1]) + 1);
//     const isDigit2 = Boolean(parseInt(rec2[1]) + 1);
//     if (!isDigit1 && !isDigit2) {
//       // If both letter-strings are equal - compare identifiers.
//       if (rec1[1] === rec2[1]) {
//         if (rec1[0] === rec2[0]) {
//           return 0;
//         }
//         else if (rec1[0] < rec2[0]) {
//           return -1;
//         }
//         else {
//           return 1;
//         }
//       }
//       else if (rec1[1] < rec2[1]) {
//         // First letter-string is less than second.
//         return -1;
//       }
//       else {
//         // First letter-string is greater than second.
//         return 1;
//       }
//     }
//     else if (isDigit1 && isDigit2) {
//       // Both are digit-strings - stay at original position.
//       return 0;
//     }
//     else if (isDigit1 && !isDigit2) {
//       // First digit-string is greater than second Letter-string.
//       return 1;
//     }
//     else {
//       // First Letter-string is less than second digit-string.
//       return -1;
//     }
//   });
//   return logs;
// }

// const logs = [
//   "dig1 0 1 5 1",
//   "let1 art can",
//   "dig2 3 6",
//   "let2 own kit dig",
//   "let3 art zero"
// ];

// console.log(getSortedLogs(logs));

const bubbleSort = require('./algo/sort/bubble');
const selectionSort = require('./algo/sort/selection');
const insertionSort = require('./algo/sort/insertion');
const mergeSort = require('./algo/sort/merge');
const quickSort = require('./algo/sort/quick');

const input = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0, 3, 3, 3, 3, 3];
console.log(input.join(','));

console.log(bubbleSort(input.slice(0)).join(','));
console.log(selectionSort(input.slice(0)).join(','));
console.log(insertionSort(input.slice(0)).join(','));
console.log(mergeSort(input.slice(0)).join(','));
console.log(quickSort(input.slice(0)).join(','));